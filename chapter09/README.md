# 并发

## Goroutine Go 运行时管理的轻量级线程
示例:
```go
go f(x, y, z)
```
x, y, z 为参数, f 为函数。x, y, z 的求值发生在当前的 goroutine 中, 而 f 的执行发生在新的 goroutine 中。

## Channel 
> 通道是一种类型化的管道, 可以用于通过它们发送类型化的值到信道中进行通信
- 通道是引用类型，通道类型的空值是 nil;
- 通道的声明形式：var 通道名 chan 通道类型;
- 通道的初始化形式：通道名 = make(chan 通道类型, [缓冲大小])
示例:
```go
ch <- v    // 将 v 发送至通道 ch
v := <-ch  // 从 ch 接收值并赋予 v
```
通道是带有类型的管道, 可以通过它用通道操作符 *<-* 来发送或者接收值。

```go
ch := make(chan int)
```
通道通过 make 创建, 默认是无缓冲的, 也就是说只有在对应的接收（<- chan） 通道准备好接收时, 才允许进行发送（chan <-） 通道的操作。
> *发送和接收必须同时准备好*
### 通道的缓冲
- 通道可以是有缓冲的。为 make 提供第二个参数作为缓冲长度来初始化一个缓冲通道：
- 缓冲填满后发送会阻塞，缓冲为空时接收会阻塞。
```go
ch := make(chan int, 2)
```
- 获取通道的缓冲区大小
```go
// 结果为 2
cap(ch)
```
- 向带缓冲的通道发送数据的时候, 只有在缓冲区满的时候才会阻塞。 而当缓冲区为空的时候接收操作会阻塞。
### 通道的遍历与关闭
通过 range 遍历通道
```go
for i := range ch {
    fmt.Println(i)
}
// 只有在通道 c 被关闭的情况下, 上面的循环才会结束。通道不像文件之类的，不需要经常去关闭, 只有当你确实没有任何发送数据了, 或者你想显式的结束 range 循环之类的。
```
- range 要配合 close 使用,一般情况下不需要关闭通道, 只有在需要告诉接收者不会再有值发送的时候才有必要关闭通道。
- 向一个已经关闭的通道发送数据会引发 panic。
- 通道关闭后, 仍然可以从通道接收数据, 但是数据都是通道类型的零值。
```go
close(ch)
```
### 通道的选择器 select 
- select 语句使一个 Go 程可以等待多个通信操作;
- select 会阻塞到某个分支可以继续执行为止, 这时就会执行该分支。当多个分支都准备好的时候会随机选择一个执行;
- default 分支当其它所有 case 分支都在阻塞时就会执行。