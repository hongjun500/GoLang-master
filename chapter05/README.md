### 第五章节
 - 数组
   - 数组的声明方式是 var varName [len]T 如果len是三个点(...)那么数组长度将根据数据初始化时的个数来决定
   - 数组的中的元素都有零值，根据数组类型T决定，int是0，string是空字符串
   - 数组的长度是常量，因此是不可变的
   - 数组的无法比较大小，只能比较是否相等，长度和值一样才相等
 - 切片数组:slice
   - 切片的声明方式是 var varName []T
   - 切片长度是可变的，更加灵活 
   - 切片的底层就是指向数组的指针，在引用某个切片A得到另一个切片B时(切片截取)，改变切片B的元素内容，切片A的内容也会随之改变(这本质上就是指针的特征)
   - 切片可以通过内置函数 make([]T,len,cap)进行初始化创建
      > len必须指定，cap可以不指定并且在指定cap的值时cap的值必须要大于等于len 
     
      > 切片的截取时最终得到的切片会根据slice[begin:end]中上界下界的值进行界定，而写法有多种要么没定义上界要么没定义下界，总的来说下界定义了
     就是最后一个元素取下标为下界值减一，反之则是都要(加深自我理解) 
   - 内置函数copy(new []Type, src []Type)也可以将切片src的值覆盖到切片new里面，返回的值是拷贝元素的个数，并且由两者之间最小长度决定
   - 内置函数append(slice []Type, elems ...Type), 将元素拼加到slice后面得到一个新的切片(这个elems可以是一个同类型的切片)
 - map
   > 元素对的无序集合
   > 在Golang中因为线程安全的问题将map分为了无锁的map和自带锁的 sync.Map
     - 无锁map
       - 声明方式var mapName map[T]T
       - 初始化使用make关键字 make(map[T]T)
       - map的取值：mapName["key"],该表达式会返回两个元素，一个是值，一个是布尔类型的判断key是否存在于该map中
       - map的遍历可以使用for循环加上range关键字
       - map删除元素可以使用内置函数delete(m map[Type]Type1, key Type),并且如果key不存在也不会有问题(排除极端情况)
     - sync.Map